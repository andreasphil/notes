---
date: 2025-09-01
icon: ðŸ’¨
title: Supply-chain security, platform APIs, evil package managers
---

In light of the recent supply-chain attacks in the NPM and Node world ([this](https://socket.dev/blog/tinycolor-supply-chain-attack-affects-40-packages) one and [that](https://socket.dev/blog/ongoing-supply-chain-attack-targets-crowdstrike-npm-packages) one), we're starting with some food for thought about protecting ourselves from malicious dependencies. Obsidian's philosophy of [*Less is safer*](https://obsidian.md/blog/less-is-safer/) is the best collection of measures to mitigate the risk of successful supply-chain attacks I've seen so far. In short:

- Avoid dependencies if possible
- Re-implement or [vendor](https://htmx.org/essays/vendoring/) small to medium dependencies (if licensing allows)
- Update large dependencies only periodically after careful manual review
- Block postinstall scripts
- Pin dependencies to patch versions
- Install strictly what's in the lockfile (`npm ci`)
- Delay updates, as malicious packages are usually detected within hours.

This sounds reasonable to me. Yet it's also quite different from our current practice of mostly immediate, mostly automated updates. Interested in hearing your thoughts ðŸ§ 

It can also be tricky to avoid dependencies. In Norms, for example, we have [very few client-side dependencies.](https://github.com/digitalservicebund/ris-norms/blob/main/frontend/package.json) But our toolchain for linting, formatting, and testing is pretty complex. I don't see how we can reduce that by much without compromising code quality and consistency. This is one of the reasons I'm excited about [Vite+,](https://voidzero.dev/posts/whats-new-jul-2025#what-s-vite) the Vite team's attempt at replacing the zoo of linters, formatters, test runners, etc. with a unified toolchain. We'll learn more at this year's [ViteConf!](https://viteconf.amsterdam/)

---

- [Are package managers evil?](https://www.gingerbill.org/article/2025/09/08/package-managers-are-evil/) An interesting **argument against automating dependency management** in the first place. I tend to agree. In fact I have started vendoring stuff manually for small, personal projects. But as mentioned above, I don't have good ideas for making this practical for bigger projects that involve many people.

- A good way of reducing dependencies is using features that the platform already offers. Did you know the browser has an [**internationalization API?**](https://www.smashingmagazine.com/2025/08/power-intl-api-guide-browser-native-internationalization/) Among other things, you can use it for formatting dates, relative time, and numbers. Similarly, the [**Temporal API**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal) already works in Firefox and can be [polyfilled](https://github.com/fullcalendar/temporal-polyfill) in other browsers, removing the need to use dayjs or similar libraries. The browser also has [**APIs for client-side form validation**](https://www.youtube.com/watch?v=h5qqmE83Tes) that can get you pretty far for many basic use cases.

- In my recent post about Tailwind I argued that **CSS is much more dynamic** than it used to be. If you had no idea what I was talking about, here are some good examples: [subgrid & container queries change how we can create layouts,](https://www.youtube.com/watch?v=Zddz_R1RnfM) and [a new approach to container and wrapper classes.
](https://www.youtube.com/watch?v=c13gpBrnGEw)

- [What if AI doesn't get much better than this?](https://www.youtube.com/watch?v=WwI8Q80-73s)

- The [Progressive Complexity Manifesto](https://www.lorenstew.art/blog/progressive-complexity-manifesto/) lays out a useful **mental model for thinking about server-side rendering and client-side interactivity** beyond the static vs. single-page app binary.

- [tldr](https://github.com/tldr-pages/tldr?utm_source=one-tip-a-week.beehiiv.com&utm_medium=referral&utm_campaign=one-tip-a-week-tlrc) is **a project to make man pages more approachable** by giving you the most important ways of running commands in an easy to read format. You can use their [client](https://one-tip-a-week.beehiiv.com/p/one-tip-a-week-tlrc) to run it in your terminal or try it on the [web.](https://tldr.inbrowser.app/)

- The new Apple OSes have been released and with them the (controversial) **liquid glass design.** Be that as it may, people have attempted to [recreate it on the web.](https://kube.io/blog/liquid-glass-css-svg/) Always love to see that type of experimentation! Wouldn't be required though if we had access to [Apple's private CSS property](https://alastair.is/apple-has-a-private-css-property-to-add-liquid-glass-effects-to-web-content/) that enables the effect.

- New Apple OSes also come with a [**new major version of Safari.**](https://webkit.org/blog/17333/webkit-features-in-safari-26-0/) Recently they've been packed with features, and this year is no different. Among others, [anchor positioning,](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_anchor_positioning) [scroll-driven animations,](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll-driven_animations) and SVG favicons are now supported in Safari, which should get them closer to Baseline availability.

- [**Java 25**](https://www.baeldung.com/java-25-features) has been released with some nice quality of life features such as more flexible constructors, top-level `main` methods, and a new way to import things.
